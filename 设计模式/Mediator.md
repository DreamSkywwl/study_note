---
title:Mediator 中介模式
---

# Mediator 中介模式
**对象行为型模式**

## 意图
+ 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

## 动机
+ 面对对象设计鼓励将行为分布到各个对象中。这种分布可能会导致对象间有许多的连接。在最坏的情况下，每一个对象都知道其他所有对象。
+ 虽然将一个系统分割成许多对象通常可以增强可复用性，但是对象间相互连接的激增又会降低其可复用性。大量的相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作--系统表现为一个不可分割的整体。而且，对系统的行为进行较大的改动都十分困难，因为行为分布在许多对象中。结果是，你可能不得不定义很多子类以定制系统的行为。

## 适用性
+ 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
+ 一个对象引用其他很多对象并且直接与这些对象进行通信，导致难以复用该对象。
+ 想定制一个分布在多个类中的行为，但又不想生成太多子类。

## 参与者
1. Mediator
   + 中介者定义一个接口用于与各个同事（Colleague）对象通信。
2. ConcreteMediator
   + 具体中介者通过协调各同事对象实现协作行为。
   + 了解并维护它的各个同事。
3. Colleague class
   + 每一个同事都知道它的中介者对象。
   + 每一个同事对象要与其他同事对象通信的时候，与它的中介者通信。

## 协作
+ 同事向一个中介者对象发送和接受请求。直接走在各个同事间适当地转发请求以实现协作行为。

## 效果
1. **减少了子类的生成** Mediator将原本分布于多个对象间的行为集中在一起，改变这些行为只需要生成Mediator的子类即可。这样各个Colleague类可以被重用。
2. **它将各Colleague解耦** Mediator有利于各Colleague间的松耦合。你可以独立的改变和复用各Colleague类和Mediator类。
3. **它简化了对象协议** 用Mediator和Colleague间的一对多交互来代替多对多的交互。一对多的关系更易于理解、维护和扩展。
4. **它对对象如何协作进行了抽象** 将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。
5. **它是控制集中化** 中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议，它可能变得比任一个Colleague都复杂。这可能使得中介者自身成为一个难于维护的庞然大物。