# 死锁的四个必要条件

操作系统中有若干进程并发执行，它们不断申请、使用、释放系统资源，虽然系统的进程协调、通信机构会对它们进行控制，但也可能出现若干进程都相互等待对方释放资源才能继续运行，否则就阻塞的情况。此时，若不借助外界因素，谁也不能释放资源，谁也不能解除阻塞状态。根据这样的情况，操作系统中的`死锁`被定义为系统中两个或者多个进程无限期地等待永远不会发生的条件，系统处于停滞状态，这就是死锁。

死锁：是指两个或两个以上的进程在执行过程中，因`争夺资源`而造成的一种`互相等待`的现象，若无外力作用，它们都将无法推进下去。

## 产生死锁的原因主要是：
1. 因为系统资源不足。
2. 进程运行推进的顺序不合适。
3. 资源分配不当等。

如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则
就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

## 产生死锁的四个必要条件：
1. 互斥条件：一个资源每次只能被一个进程使用。
2. 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

## 死锁的解除与预防：
理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划

## 处理死锁的基本方法：

+ 死锁预防：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。

+ 死锁避免：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。

+ 死锁检测：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。

+ 死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。

## 死锁预防
破坏死锁的四个条件中的一个或几个。
1. 互斥：它是设备的固有属性所决定的，不仅不能改变，还应该加以保证。
2. 占有且等待：为预防占有且等待条件，可以要求进程一次性的请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。这个方法比较低效。
3. 不可抢占：预防这个条件的方法：
	+ 如果占有某些资源的一个进程进行进一步资源请求时被拒绝，则该进程必须释放它最初占有的资源。
	+ 如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另外一个进程，要求它释放资源。
4. 循环等待：通过定义资源类型的线性顺序来预防。
	+ 如果一个进程已经分配了R类资源，那么接下来请求的资源只能是那些排在R类型之后的资源类型。该方法比较低效。



## 死锁避免
1. 两种死锁避免算法：
	+ 进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程。
	+ 资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配(银行家算法)。
2. 银行家算法：
	1. 如果request<=need，转向步骤2；否则认为出错，因为请求资源大于需要资源。
	2. 如果request<=available，转向步骤3,；否则尚无足够资源，进程p阻塞；
	3. 系统尝试为把资源分配给进程P，并修改available、allocation和need的数值。
	4. 系统执行安全性算法，检查此次分配后系统是否处于安全状态，若安全，才正式将资源分配给进程P，否则将本次试探性分配作废，让进程P等待。
	+ 安全状态：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。

3. 安全性算法：
	1. 设置两个向量：
		+ 工作向量work：表示系统可提供给进程继续运行的所需的各类资源的数目，执行安全算法开始时，work=available。
		+ finish：表示系统是否有足够资源分配给进程，使之运行完成。开始时先做finish[i]=false；当有足够资源分配给进程时再令finish[i]=true。
	2. 从进程集合找到一个满足下列条件的进程：
		+ finish[i]=false；
		+ need<=work；
		+ 若找到执行步骤3；否则执行步骤4；
	3. 当进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：
		+work=work+allocation(P)；
		+finish[i]=true；
		+循环执行步骤2；
	4. 如果所有进程的finish=true，则表示系统处于安全状态；否则，系统处于不安全状态。

## 死锁检测和解除
1. 死锁检测算法。
2. 死锁的解除：
+ 两种常用的死锁解除方法：剥夺资源和撤销进程。