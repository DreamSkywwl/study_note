---
title:Facade 外观模式
---

# Facade 外观模式
对象结构型模式


## 意图
+ 为子系统中一组接口提供一个一致的界面，Facade模式定义了一个高层的接口，这个接口使得这一子系统更加容易使用。
+ 组件构建过程中，某些接口的直接依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的方案。

## 动机
+ 将一个系统划分成若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。达到该目标的途径之一就是引入一个facade对象，它为子系统中较一般的设施提供了一个单一而简单的界面。

## 适用性
+ 当你要为一个复杂的子系统提供一个简单接口时。子系统往往因为不断演化变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。facade可以提供一个简单的缺省视图，这个视图对于大多数用户来说已经足够，而那些需要更多可定制性的用户可以越过facade层。
+ 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade将这个子系统与客户以及其他子系统分离，可以提高子系统的独立性与可移植性。
+ 当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让他们仅通过facade进行通讯，从而简化了它们之间的依赖关系。

## 参与者
+  Facade
   +  知道哪些子系统类负责处理请求
   +  将客户的请求代理给适当的子系统对象
+ Subsystem classes
  + 实现子系统功能
  + 处理由Facade对象指派的任务
  + 没有facade的任何相关信息；即没有指向facade的指针


## 协作
+ 客户程序通过发送请求给Facade的方式与子系统通讯，Facade将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。
+ 使用Facade的客户程序不需要直接访问子系统对象。


## 效果
1. 它对客户屏蔽子系统组件，因此减少了客户处理的对象的数目并使得子系统使用起来更方便。
2. 它实现了子系统和客户之间松耦合的关系，而子系统内部的组件往往是紧耦合的。松耦合关系使得子系统组件的变化不会影响到它的客户。Facade模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。Facade模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要。
   在大型软件系统中降低编译依赖性至关重要。在子系统改变时，希望尽量减少重新编译工作以节省时间。用Facademo模式可以降低编译依赖性，限制重要系统中较小的变化所需的重新编译工作。Facade模式同样也有利于简化系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。
3. 如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。