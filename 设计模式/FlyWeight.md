---
title:FlyWidght 享元模式
---

# FlyWidght 享元模式

## 意图
+ 运用共享技术有效地支持大量细粒度的对象。

## 动机
+ 有些应用程序得益于在其整个设计过程中采用对象技术，但简单化的实现代价极大。
+ 在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价--主要指内存需求方面。
    + 例如，大多数文档编辑器的实现都有文本格式化和编辑功能，这些功能一定程度上是模块化的。面向对象的文档编辑器通常使用对象来表示嵌入的成分，例如图形和表格。尽管用对象来表示的每个字符会极大地提高应用程序的灵活性，但是这些编辑器通常并不这么做。字符和嵌入成分可以在绘制和格式化时统一处理，从而在不影响其他功能的情况下能对应用程序进行扩展，支持新的字符集。

## 适用性
+ Flyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当一下情况成立时使用Flyweight模式：
  + 一个应用程序使用了大量的对象。
  + 完全由于使用大量的对象，造成很大的存储开销。
  + 对象的大多数状态都可变为外部状态。
  + 如果删除对象的外部状态那么可以用相对较少的共享对象取代很多组对象。
  + 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回其真值。


~~~ java
public class Font {
    private String key;

    public Font(String key) {
        this.key = key;
    }
}

public class FontFactory {
    private Map<String, Font> fontPool = new HashMap<>();

    Font getFont(final String key) {
        Font font = fontPool.get(key);

        if (font != null) {
            //获取到已存在对象
            return font;
        } else {
            //无存在对象，重新生成新对象
            font = new Font(key);
            fontPool.put(key, font);
            return font;
        }
    }
}
~~~

## 要点总结
+ 面对对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决了面对对象的代价问题，一般不触及面向对象的抽象性问题。
+ Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的压力。在具体实现方面，要注意对对象状态的处理。