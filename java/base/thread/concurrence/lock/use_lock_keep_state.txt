####################################################
使用锁来保护状态
####################################################
因为锁使得线程能够串行*访问它所保护的代码路径，所以我们可以用锁来创建相关的协议，以保证线程对共享状态的独占访问。
只要始终如一的遵循这些协议，就能够确保状态的一致性。

串行：对象的串行(Serializing)访问与对象的序列化(Serialization，将对象序列化为字节流)毫无关系，
    不间断访问意味着线程依次独占地访问对象，而不是并发访问。

####################################################
操作共享状态的复合操作必须是原子的，以避免竞争条件，比如递增命中计数器（读-改-写）或者惰性初始化
（检查再运行）。复合操作会在完整的运行期间占有锁，已确保其行为是原子的。
然而，仅仅使用synchronized块包装复合操作是不够的；如果用同步来协调访问变量，每次访问变量时都需要同步。
退一步讲，用锁来协调访问变量时，每次访问变量都需要用同一个锁。

####################################################

对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，
我们称这个变量由这个锁保护的。

####################################################
每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁。

####################################################
对于每一个涉及多个变量的不变约束，需要同一个锁保护其所有的变量
####################################################