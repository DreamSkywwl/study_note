######################################################
如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例
######################################################

在 Java 中可以用 wait、notify 和 notifyAll 来实现线程间的通信。举个例子，
如果你的Java程序中有两个线程——即生产者和消费者，那么生产者可以通知消费者，让消
费者开始消耗数据，因为队列缓冲区中有内容待消费（不为空）。相应的，消费者可以通知
生产者可以开始生成更多的数据，因为当它消耗掉某些数据后缓冲区不再为满。

我们可以利用wait()来让一个线程在某些条件下暂停运行。例如，在生产者消费者模型中，
生产者线程在缓冲区为满的时候，消费者在缓冲区为空的时候，都应该暂停运行。如果某些
线程在等待某些条件触发，那当那些条件为真时，你可以用 notify 和 notifyAll 来通
知那些等待中的线程重新开始运行。不同之处在于，notify 仅仅通知一个线程，并且我们
不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。换言之，如果只
有一个线程在等待一个信号灯，notify和notifyAll都会通知到这个线程。但如果多个线程
在等待这个信号灯，那么notify只会通知等待队列中的第一个线程，而其它线程并不会收到
任何通知，而notifyAll会唤醒所有等待中的线程。

######################################################
如何使用Wait

尽管关于wait和notify的概念很基础，它们也都是Object类的函数，但用它们来写代码却
并不简单。如果你在面试中让应聘者来手写代码，用wait和notify解决生产者消费者问题，
我几乎可以肯定他们中的大多数都会无所适从或者犯下一些错误，例如在错误的地方使用 
synchronized 关键词，没有对正确的对象使用wait，或者没有遵循规范的代码方法。
说实话，这个问题对于不常使用它们的程序员来说确实令人感觉比较头疼。

第一个问题就是，我们怎么在代码里使用wait()呢？因为wait()并不是Thread类下的函数，
我们并不能使用Thread.call()。事实上很多Java程序员都喜欢这么写，因为它们习惯了使用
Thread.sleep()，所以他们会试图使用wait() 来达成相同的目的，但很快他们就会发现这
并不能顺利解决问题。正确的方法是对在多线程间共享的那个Object来使用wait。在生产者消
费者问题中，这个共享的Object就是那个缓冲区队列。

第二个问题是，既然我们应该在synchronized的函数或是对象里调用wait，那哪个对象应该被
synchronized呢？答案是，那个你希望上锁的对象就应该被synchronized，即那个在多个线
程间被共享的对象。在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。

######################################################
永远在循环（loop）里调用 wait 和 notify，不是在 If 语句

现在你知道wait应该永远在被synchronized的背景下和那个被多线程共享的对象上调用，下一个
一定要记住的问题就是，你应该永远在while循环，而不是if语句中调用wait。因为线程是在某些
条件下等待的——在我们的例子里，即“如果缓冲区队列是满的话，那么生产者线程应该等待”，你可
能直觉就会写一个if语句。但if语句存在一些微妙的小问题，导致即使条件没被满足，你的线程你
也有可能被错误地唤醒。所以如果你不在线程被唤醒后再次使用while循环检查唤醒条件是否被满足
，你的程序就有可能会出错——例如在缓冲区为满的时候生产者继续生成数据，或者缓冲区为空的时候
消费者开始小号数据。所以记住，永远在while循环而不是if语句中使用wait！

基于以上认知，下面这个是使用wait和notify函数的规范代码模板：
// The standard idiom for calling the wait method in Java 
synchronized (sharedObject) { 
    while (condition) { 
    sharedObject.wait(); 
        // (Releases lock, and reacquires on wakeup) 
    } 
    // do action based upon condition e.g. take or put into queue 
}

就像我之前说的一样，在while循环里使用wait的目的，是在线程被唤醒的前后都持续检查条件是否被
满足。如果条件并未改变，wait被调用之前notify的唤醒通知就来了，那么这个线程并不能保证被唤
醒，有可能会导致死锁问题。



***
在synchronized代码被执行期间，线程可以调用对象的wait()方法，释放对象锁标志，进
入等待状态，并且可以调用notify()或者 notifyAll()方法通知正在等待的其他线程。
notify()通知等待队列中的第一个线程，notifyAll()通知的是等待队列中的所有线程。