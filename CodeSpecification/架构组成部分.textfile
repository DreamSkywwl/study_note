h1. 架构组成部分

h3. 1. 程序组织(Program Organization)(*极其重要)

定义架构的主要构造块(building blocks)。各个构造块可能是个单类或者是许多类组成的系统。
应该明确定义各个构造块的责任。每个构造块应该负责某一个区域的事情，并且对其他构造块负责的区域知道的越少越好。

h3. 2. 主要的类(Major Classes)(*极其重要)

架构应该详细的定义所用的主要的类。它应该指出每个主要的类的责任，以及该类如何与其他类交互。它应该包含对类的继承体系、状态转换、对象持久化等类的描述。如果系统足够大，它应该描述如何将这些类组织成一个个子系统。

h3. 3. 数据设计(Data Design)(*极其重要)

架构设计应该描述所用到的主要文件和数据表的设计。它应该描述曾经考虑过的其他方案，并说明做出选择的理由。
架构应该详细定义所用数据库的高层组织结构的内容。架构应该解释为什么单个数据库比多个数据库要好(反之亦然)，解释为什么不用平坦的文件而要用数据库，指出与其他访问同一数据的程序的可能交互方式，说明会创建哪些数据视图等。

h3. 4. 业务规则(Business Rules)(*极其重要)

如果架构依赖于特定的业务规则，那么它就应该详细描述这些规则，并描述这些规则对系统设计的影响。例如，假定要求系统遵循这样一条业务规则：客户信息过时时间不能超过30秒。在此情况下，架构就应该描述这条规则对架构采用的"保持客户信息及时更新且同步"的方法的影响。

h3. 5. 用户界面设计(User Interface Design)(*极其重要)

用户界面常常在需求阶段进行详细说明。如果没有，就应该在软件架构中进行详细说明。架构应该定义详细的Web页面格式、GUI、命令行接口等主要元素。
架构应该模块化，以便在替换为新用户界面时而不影响业务规则和程序输出部分。

h3. 6. 资源管理(Resource Management)(*极其重要)

架构应该描述一份管理稀缺资源的计划。稀缺资源包括数据库的连接、线程、句柄(handle)等。

h3. 7. 安全性(Security)(*极其重要)

架构应该描述实现设计层面和代码层面的安全性的方法。如果先前尚未建立威胁模型(tureat model)，那么就应该在架构阶段建立威胁模型。在指定编码规范的时候就应该把安全性牢记在心，包括处理缓冲区的方法、处理非授信(untredted)数据(用户输入数据、cookies、配置数据\文件、和其他外部接口输入数据)的规则、加密、错误信息的细致程度、保护内存中的秘密数据，以及其他事项。

h3. 8. 性能(Performance)

如果需要关注性能，就应该在需求中详细定义性能目标。性能目标可以包括资源的使用，这时，性能目标应该详细定义资源(速度、内存、成本)之间的优先顺序。
架构应该提供估计的数据，并解释为什么架构师相信能达到性能目标。如果某些部分存在达不到性能的风险，那么架构也应该指出来。如果为了满足性能目标，需要在某些部分使用特定的算法或数据类型，架构也应该说清楚。架构中也可以包括各个类或各个对象的空间和时间预算。

h3. 9. 可伸缩性(Scalability)

可伸缩性是指系统增长以满足未来需求的能力。架构应该描述系统如何应对用户数量、服务器数量、网络节点数量、数据库记录数、数据库记录长度、交易量等的增长。如果预计系统不会增长，而且可伸缩性不是问题，那么架构应该明确地列出这一假设。

h3. 10. 互用性(Interoperability)

如果预计这个系统会与其他软件或者硬件共享数据或者资源，架构应该描述如何完成这一任务。

h3. 11. 国际化/本地化(Internationalization/Localization)

h3. 12. 输入/输出(Input/OutPut)

输入输出(I/O)是架构中值得注意的另一个领域。架构应该详细定义读取策略(reading scheme)是先做(look-ahead)、后做(look-behead)还是及时做(just-in-time)。而且应该描述在哪一层检测I/O错误：在字段、记录、流，或者文件的层次。

h3. 13. 错误处理(Error Procesing)(*极其重要)

架构中必须清楚的说明一种"一致地处理错误"的策略。以下为需要考虑的问题:
1. 错误处理是进行纠正还是仅仅进行检测？如果是纠正，程序可以尝试从错误中恢复过来。如果仅仅是检测，那么程序可以像“没有发生任何事情”一样继续运行，也可以退出。无论哪一种情况，都应该通知用户说检测到一个错误。
2. 错误检测是主动还是被动？系统可以主动地预测错误——例如，通过检测用户输入的有效性——也可以在不能避免错误的时候，被动的相应错误——例如，当用户输入的组合产生了一个数值溢出的错误时。前者可以扫清障碍，后者可以清除混乱。同样，无论采取哪种方案，都与用户界面有关。
3. 程序如何传播错误？程序一旦检测到错误，它可以立即丢弃引发改错误的数据；也可以把这个错误当做一个错误，并进入错误处理状态；或者可以等到所有处理完成，再通知用户在某个地方发现了错误。
4. 错误消息的处理有什么约定？如果架构没有详细定义一个一致的处理策略，那用户界面看起来就像"令人困惑的乱七八糟的抽象拼贴画"，由程序的不同部分的各种界面拼接而成。而要避免这种外观体验，架构应该建立一套有关错误消息的约定。
5. 如何处理异常(exceptions)？架构应该规定代码何时能够抛出异常，在什么地方捕获异常，如何记录(log)这些异常，以及在文档中描述异常，等等。
6. 在程序中，在什么层次上处理错误？你可以在发现错误的地方处理，可以将错误传递到专门处理错误的类进行处理，或者沿着函数调用链往上传递错误。
7. 每个类在验证其输入数据的有效性方面需要负何种责任？是每个类验证自己的数据的有效性，还是有一组负责验证整个系统的数据的有效性？某个层次上的类是否能假设它接收的数据是干净的(clean，即，没有错误)？
8. 你是希望用运行环境中内建的错误处理机制，还是想建立自己的一套机制？事实上。运行环境所拥有的某种特定的错误处理方法，并不一定是符合你的需求的最佳方法。

h3. 14. 容错性(Fault Tolerance)(*极其重要)

架构还应该详细定义所期望的容错种类。容错是增强系统可靠性的一组技术，包括检测错误；如果可能的话从错误中恢复；如果不能从错误中恢复，则包容其不利影响。
在遇到错误的时候，让系统转入某种"部分运转/partial operation"的状态，或者转入某种"功能退化/degraded functionality"的状态。系统可以自动关闭或者重启。

h3. 15. 架构的可行性(Architectural Feasibility)(*极其重要)

设计师多半会关注系统的各种能力，例如是否达到性能目标，能够在有限的资源下运转，实现环境(运行环境)是否有足够的支持。架构应该论证系统的技术可行性。如果在任何一个方面不可行都会导致项目无法实施，那么架构应该说明"这些问题是如何经过研究的"————通过验证概念的原型(proof-of-concept prototype)、研究、或其他手段。必须在全面开展构建之前解决掉这些风险。

h3. 16. 变更策略(Change strategy)(*极其重要)

对于程序员和用户来说，构建软件产品都是一个学习的过程，所以在开发过程中很可能会发生变化。这些变更来自不稳定的数据类型和文件格式、功能需求的变更、新功能特性，等等。这些变更可能是计划增加的新功能，也可能是没有添加到系统的第一个版本中的功能。因此，软件架构师面临的一个主要挑战是，让架构足够灵活，能够适应可能出现的变化。
架构应当清楚地描述处理变更的策略。架构应该列出已经考虑过的有可能会有所增强的功能，并说明“最可能增强的功能同样也是最容易实现的”。
架构应该指出“延迟提交(指推迟某些因素的确定时间，做晚绑定，以增强灵活性)”所用的策略。比如说，架构也许规定使用表驱动(table-driven)技术(而不使用硬编码的if语句)。也许它还规定“表”中的数据是保存在外部文件中，而非直接写在程序代码中，这样就能做到在不重新编译的情况下修改程序。
