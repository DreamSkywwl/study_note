######################################
类设计


######################################
编译器生成的成员函数
1.默认构造函数
    默认构造函数要么没有参数，要么所有的参数都有默认值。如果没有定义任何构造函数，
    编译器将定义默认构造函数，让你能够创建对象。
    例如，假设Star是一个类，则下述代码需要使用默认构造函数：
    Star rigrl;//create an object without explict initializion
    Star pleiades[6];//create an array of objects
    自动生成的默认构造函数的另一项，调用基类的默认构造函数以及调用本身是对象的成员
    所属类的默认构造函数。

2.复制构造函数
    复制构造函数接受其所属类的对象作为参数。
    例如，Star类的复制构造函数原型如下：Star(const Star &);
    在下述情况，将使用复制构造函数：
    #将新对象初始化为一个同类对象；
    #按值将对象传递给函数；
    #函数按值返回对象;
    #编译器生成临时对象;
    如果程序没有使用（显式或者隐式）复制构造函数，编译器将提供原型，但不提供函数定义：
    否则，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都被
    初始化为原始对象相应成员的值。如果成员为类对象，则初始化该成员时，将使用相应的类复制构造函数。

3.赋值运算符
    默认的赋值运算符用于处理同类对象之间的赋值。不要将赋值与初始化混淆了。如果创建新的对象，
    则使用初始化：如果语句修改已有对象的值，则是赋值：
    Star sirius;
    Star alpha = sirius;//initializion (one notation)
    Star dogstar;
    dogstar = sirius;//assignment
    默认赋值为成员赋值。如果成员为类对象，则默认成员赋值将使用相应类的赋值运算符。
    如果需要显式定义复制构造函数，则基于相同的原因，也需要显式定义赋值运算符。
    Star类的赋值运算符的原型如下：
    Star & Star::operator=(const char *){...}
    另一种方法是使用转换函数将字符串转换成Star对象。

######################################
其他的类方法
1.构造函数
    构造函数不同于其他类方法，因为它是创造新的对象，而其他类方法只是被现有的对象调用。
    这是构造函数不被类继承的原因之一。继承意味着派生类对象可以使用基类的方法，然而，
    构造函数在完成其工作之前，对象并不存在。

2.析构函数
    一定要定义显示析构函数来释放构造函数使用new分配的所有内存，并完成类对象所需的
    任何特殊的清理工作。对于基类，即使它不需要析构函数，也应提供一个虚析构函数。

3.转换
    使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。
    Star(const char *);//converts char * to Star
    Star(const Spectral &, int members = 1);//converts Spectral to Star
    例如：Star north; north = "polaris";调用Star::operator=(const char *)函数，
    使用Star::Star(const char *)生成一个Star对象，该对象将被用做上述赋值运算符的参数。

4.按值传递对象与传递引用
    通常，编写使用对象作为参数的函数时，应按引用而不是按值来传递对象，这样做原因之一
    是为了提高效率。按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数。
    调用这些函数需要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修改对象，
    应将参数声明为const引用。
    按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以
    接受派生类。

5.返回对象和返回引用
    Star noval(const Star &);//return a Star object
    Star & noval2(const Star &);//return a reference to a Star
    如果可以不返回对象，则应该返回引用。返回引用而不是返回对象的原因在于，返回对象涉及生成返回
    对象的临时脚本，这是调用函数的程序可以使用的副本。因此，返回对象的时间成本包括调用复制构造函数
    来生成副本所需的时间和调用析构函数删除副本所需的时间。返回引用可节省时间和内存。
    直接返回对象和按值传递对象相似：它们都生成临时副本对象。
    返回引用与按值引用传递对象相似：调用和被调用的函数对同一个对象进行操作。

    函数不能返回在函数中创建的临时对象的引用，因为当函数结束时，临时对象将消失，这种引用时非法的，
    在这种情况下，应返回对象，以生成一个调用程序可以使用的副本。
    通用规则是，如果函数返回在函数中创建临时对象，则不要使用引用。例如：
    Vector Vector::operator+(const Vector & b) const{
        return Vector(x + b.x, y + b.y);
    }

    如果函数返回的是通过引用或指针传递给它的对象，则应按引用返回对象。例如：
    const Stock & Stock::topval(const Stock & s) cosnt{
        if(s.total_val > total_val)
            return s;//argument object
        else
            re *this;//invoking object
    }

6.使用const
    使用const应该特别注意。
    可以使用它来确保方法不修改参数。可以使用const来确保方法不修改调用它的对象。

    

