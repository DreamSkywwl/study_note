initialzation


####################################
class Bakery{
    private:
        enmu {Months = 12};
        double conts[Months];
}
##该方式声明枚举不会创建类的数据成员。也就是说所有对象都不包含枚举。另外，Months只是一个符号名称，
在作用域为整个类的代码遇到它时，编译器用12来替代它。

####################################
class Bakery{
    private:
        static const int Months = 12;
        double conts[Months];
}
##这将创建一个名为Months的常量，该常量与其他静态变量存储在一起，而不是存储在对象中。
因此，只有一个Months常量，被所有Bakery对象共享。


####################################
class初始化 与 析构函数 的关联

1.如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。
2.new和delete必须相互兼容。new对应delete，new[]对应delete[]。
3.如果有多个构造函数，则必须以相同的方式使用new，要么都是用new，要么都带中括号，要么都不带
  因为只有一个析构函数，所有构造函数都必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，
  在另一个构造函数中将指针初始化为空（0或者c++11中的nullptr），这是因为delete可以用于空指针（无论是否带中括号）


####################################